// This board design implments an FMC card that contains a wide-band
// DAC for the synthesis of radar waveforms.  The FMC card is intended to
// be installed on a Xilinx ML605 evaluation board.
design fmc_dac is

    // device definitions
    include "devices.phdl";

    // Power and ground nets.
    net +3V3, +2V5, +1V8, 1V8_sense, gnd;
    net VDDC, VDDA;

    // DAC Signals.
    net IOUTP, IOUTN;
    net[13:0] DB1_P, DB1_N, DB0_P, DB0_N;
    net DACCLK_P, DACCLK_N, DCI_P, DCI_N, DCO_P, DCO_N, SYNC_IN_P, SYNC_IN_N, SYNC_OUT_P, SYNC_OUT_N;
    net SPI_CS, SPI_SCLK, SPI_SDO, SPI_SDI;
    net RESET, IRQ, DAC_VREF, IPTAT, I120;
    net analog_out;

    // Clock signals.
    net samp_clk_in, bal_clock_p, bal_clock_n, coup_clock_p, coup_clock_n;
    net clock_buf_p, clock_buf_n;
    net ADCLK914_Vref;

begin

    // This the fast DAC itself. Note how concisely the busses are connected.
    inst fast_dac of ad9739 is refDes = "U1";
        VDDC = <VDDC>;
        VSSC = <gnd>;
        VDDA = <VDDA>;
        VSSA = <gnd>;
        VSSA_SHIELD = <gnd>;
        NC = open;
        IOUTN = <IOUTN>;
        IOUTP = <IOUTP>;
        I120  = I120;
        VREF  = DAC_VREF;
        IPTAT = IPTAT;
        DACCLK_N = DACCLK_N;
        DACCLK_P = DACCLK_P;
        IRQ   = IRQ;
        RESET = RESET;
        CS = SPI_CS;
        SDIO = SPI_SDI;
        SCLK = SPI_SCLK;
        SDO  = SPI_SDO;
        VDD33 = <+3V3>;
        VDD = <+1V8>;
        VSS = <gnd>;
        SYNC_OUT_P = SYNC_OUT_P;
        SYNC_OUT_N = SYNC_OUT_N;
        SYNC_IN_P = SYNC_IN_P;
        SYNC_IN_N = SYNC_IN_N;
        DCO_P = DCO_P;
        DCO_N = DCO_N;
        DCI_P = DCI_P;
        DCI_N = DCI_N;
        DB1_P = DB1_P;
        DB1_N = DB1_N;
        DB0_P = DB0_P;
        DB0_N = DB0_N;
    end inst;

    // SMA connector for the analog output.
    inst sma_analog_out of SMA_CON is refDes="J2"; sig=analog_out; gnd=<gnd>;  end inst;
    // the output balun transformer and associated bias resistors.
    inst output_balun of MABACT0039 is refDes="T1";
        input=analog_out; gnd=gnd; out_coupled=IOUTN; out_thru=IOUTP;
    end inst;
    inst analog_bal_resP of res_0603 is refDes="R4"; value="90.1/1%"; a=IOUTP;  b=gnd; end inst;
    inst analog_bal_resN of res_0603 is refDes="R5"; value="90.1/1%"; a=IOUTN;  b=gnd; end inst;
    // Some caps and resistors for the DAC.
    inst vref_res   of capnp_0603 is refDes="C19";  value="1000PF/X7R/10V"; a=DAC_VREF; b=gnd; end inst;
    inst I120_res   of res_0603 is refDes="R6"; value="10K/1%"; a=I120;  b=gnd;  end inst;
    inst IPTAT_res  of res_0603 is refDes="R7"; value="10K/1%"; a=IPTAT; b=gnd;  end inst;
    inst IRQ_PULLUP of res_0603 is refDes="R8"; value="10K/1%"; a=IRQ;   b=+3V3; end inst;
    inst clk_term   of res_0603 is refDes="R9"; value="100/1%"; a=DACCLK_P; b=DACCLK_N; end inst;
    // Power filtering and decoupling for AD9739.
    // For VDDC
    inst L1  of ELKE  is refDes="L1"; in=+1V8; out=VDDC; gnd=gnd; end inst;
    inst C3  of capnp_0603 is refDes="C3";  value="0.01UF/X7R/10V"; a=VDDC; b=gnd; end inst;
    inst C4  of capnp_0603 is refDes="C4";  value="0.01UF/X7R/10V"; a=VDDC; b=gnd; end inst;
    inst C5  of capnp_0603 is refDes="C5";  value="1000PF/X7R/10V"; a=VDDC; b=gnd; end inst;
    inst C6  of capnp_0603 is refDes="C6";  value="1000PF/X7R/10V"; a=VDDC; b=gnd; end inst;
    // For VDDA
    inst L2  of ELKE  is refDes="L2"; in=+1V8; out=VDDA; gnd=gnd; end inst;
    inst C7  of capnp_0603 is refDes="C7";  value="0.01UF/X7R/10V"; a=VDDA; b=gnd; end inst;
    inst C8  of capnp_0603 is refDes="C8";  value="0.01UF/X7R/10V"; a=VDDA; b=gnd; end inst;
    inst C9  of capnp_0603 is refDes="C9";  value="1000PF/X7R/10V"; a=VDDA; b=gnd; end inst;
    inst C10 of capnp_0603 is refDes="C10"; value="1000PF/X7R/10V"; a=VDDA; b=gnd; end inst;
    // For +3V3
    inst C11 of capnp_0603 is refDes="C11"; value="0.01UF/X7R/10V"; a=+3V3; b=gnd; end inst;
    inst C12 of capnp_0603 is refDes="C12"; value="0.01UF/X7R/10V"; a=+3V3; b=gnd; end inst;
    inst C13 of capnp_0603 is refDes="C13"; value="1000PF/X7R/10V"; a=+3V3; b=gnd; end inst;
    inst C14 of capnp_0603 is refDes="C14"; value="1000PF/X7R/10V"; a=+3V3; b=gnd; end inst;
    // For +1V8
    inst C15 of capnp_0603 is refDes="C15"; value="0.01UF/X7R/10V"; a=+1V8; b=gnd; end inst;
    inst C16 of capnp_0603 is refDes="C16"; value="0.01UF/X7R/10V"; a=+1V8; b=gnd; end inst;
    inst C17 of capnp_0603 is refDes="C17"; value="1000PF/X7R/10V"; a=+1V8; b=gnd; end inst;
    inst C18 of capnp_0603 is refDes="C18"; value="1000PF/X7R/10V"; a=+1V8; b=gnd; end inst;



    // These are the four mounting holes required by the FMC standard.
    inst mounting_hole1 of mount_hole_125 is refDes="MTG1"; pin1=open; end inst;
    inst mounting_hole2 of mount_hole_125 is refDes="MTG2"; pin1=open; end inst;
    inst mounting_hole3 of mount_hole_125 is refDes="MTG3"; pin1=open; end inst;
    inst mounting_hole4 of mount_hole_125 is refDes="MTG4"; pin1=open; end inst;



    // Here we create the 1.8V supply
    inst LDO of LT3022 is refDes="U2";
        NC=open; OUT=<+1V8>; ADJ_SENSE=1V8_sense; AGND=<gnd>; SHDN_N=+3V3; PGND=<gnd>; IN=<+3V3>; GND_PAD=gnd;
    end inst;
    inst C1 of capnp_1210 is refDes="C1"; value="22UF/X7R/25V"; a=+3V3;      b=gnd; end inst;
    inst C2 of capnp_1210 is refDes="C2"; value="22UF/X7R/25V"; a=+1V8;      b=gnd; end inst;
    inst R2 of res_0805   is refDes="R2"; value="1500/1%";      a=+1V8;      b=1V8_sense; end inst;
    inst R3 of res_0805   is refDes="R3"; value="187/1%";       a=1V8_sense; b=gnd; end inst;



    // Clock buffer section.
    inst sma_samp_clk   of SMA_CON is refDes="J1"; sig=samp_clk_in; gnd=<gnd>; end inst;
    inst clock_balun of RFXF9503 is refDes   = "T2";
        nc       = open;
        sec_dot  = bal_clock_p;
        sec      = bal_clock_n;
        prim_dot = samp_clk_in;
        prim     = gnd;
    end inst;
    // Some AC coupling caps after the clock balun.
    inst coup_cap_p of capnp_0603 is refDes="C20";  value="1000PF/X7R/10V"; a=bal_clock_p; b=coup_clock_p; end inst;
    inst coup_cap_n of capnp_0603 is refDes="C21";  value="1000PF/X7R/10V"; a=bal_clock_n; b=coup_clock_n; end inst;
    inst clock_buffer of ADCLK914 is refDes = "U3";
        D_P = coup_clock_p;
        D_N = coup_clock_n;
        NC = open;
        Vee = <gnd>;
        Vcc = <+3V3>;
        Q_N = clock_buf_n;
        Q_P = clock_buf_p;
        Vref = ADCLK914_Vref;
        Vt   = ADCLK914_Vref;
        THERMAL_PAD = gnd;
    end inst;



    // This is the big High Pin Count FMC connector.
    // I broke up the pin list into the diff pairs because the DAC uses LVDS I/O.
    inst docking_connector of asp_134488 is
        refDes = "P64";

        //  we don't use row A since it is all GTP.
        a[2,3,6,7,10,11,14,15,18,19,22,23,26,27,30,31,34,35,38,39] = open;
        //  we don't use row B since it is all GTP.
        b[1,4,5,8,9,12,13,16,17,20,21,24,25,28,29,32,33,36,37,40] = open;

        // Row C has some differential lines.
        c[10,11] = open;
        c[14,15] = open;
        c[18,19] = open;
        c[22,23] = open;
        c[26,27] = open;
        c[39]    = +3V3;
        c[2,3,6,7,30,31,34,35,37] = open;

        // Row D has some differential lines.
        d[8,9]   = open;
        d[11,12] = open;
        d[14,15] = open;
        d[17,18] = open;
        d[20,21] = open;
        d[23,24] = open;
        d[26,27] = open;
        d[36,38,40] = <+3V3>;
        d[1,4,5,29,30,31,32,33,34,35] = open;

        // Row E has diff pairs.
        e[2,3]   = SYNC_OUT_P & SYNC_OUT_N;
        e[6,7]   = DB1_P[0] & DB1_N[0];
        e[9,10]  = DB1_P[1] & DB1_N[1];
        e[12,13] = DB1_P[2] & DB1_N[2];
        e[15,16] = DB1_P[3] & DB1_N[3];
        e[18,19] = DB1_P[4] & DB1_N[4];
        e[21,22] = DB1_P[5] & DB1_N[5];
        e[24,25] = DB1_P[6] & DB1_N[6];
        e[27,28] = DB1_P[7] & DB1_N[7];
        e[30,31] = DB1_P[8] & DB1_N[8];
        e[33,34] = DB1_P[9] & DB1_N[9];
        e[36,37] = open; // really NC.
        e[39]    = +2V5;

        // Row F has diff pairs.
        f[4,5]   = DCO_P & DCO_N;
        f[7,8]   = DB1_P[10] & DB1_N[10];
        f[10,11] = DB1_P[11] & DB1_N[11];
        f[13,14] = DB1_P[12] & DB1_N[12];
        f[16,17] = DB1_P[13] & DB1_N[13];
        f[19,20] = DCI_P & DCI_N;
        f[22,23] = SYNC_IN_P & SYNC_IN_N;
        f[25,26] = open;
        f[28,29] = open;
        f[31,32] = open;
        f[34,35] = open;
        f[40]    = +2V5;
        f[1,37,38] = open;

        // Row G has diff pairs.
        g[6,7]   = DB0_P[0] & DB0_N[0];
        g[9,10]  = DB0_P[1] & DB0_N[1];
        g[12,13] = DB0_P[2] & DB0_N[2];
        g[15,16] = DB0_P[3] & DB0_N[3];
        g[18,19] = DB0_P[4] & DB0_N[4];
        g[21,22] = DB0_P[5] & DB0_N[5];
        g[24,25] = DB0_P[6] & DB0_N[6];
        g[27,28] = DB0_P[7] & DB0_N[7];
        g[30,31] = DB0_P[8] & DB0_N[8];
        g[33,34] = DB0_P[9] & DB0_N[9];
        g[36,37] = open;
        g[39]    = +2V5;
        g[2,3] = open;

        // H has diff pairs.
        h[1]     = gnd;  // indicates presence of FMC module.
        h[7,8]   = open;
        h[10,11] = DB0_P[10] & DB0_N[10];
        h[13,14] = DB0_P[11] & DB0_N[11];
        h[16,17] = DB0_P[12] & DB0_N[12];
        h[19,20] = DB0_P[13] & DB0_N[13];
        h[22,23] = open;
        h[25,26] = open;
        h[28,29] = open;
        h[31,32] = open;
        h[34,35] = open;
        h[37,38] = open;
        h[40]    = +2V5;
        h[2,4,5] = open;

        // J diff pairs.
        j[6,7]   = open;
        j[9,10]  = open;
        j[12,13] = open;
        j[15,16] = open;
        j[18,19] = open;
        j[21,22] = open;
        j[24,25] = open;
        j[27,28] = open;
        j[30,31] = open;
        j[33,34] = open;
        j[36,37] = open;
        j[39] = +2V5;  // here we feed the 2.5V back to the carrier.
        j[2,3] = open;

        // K diff pairs.
        k[7,8]   = open;
        k[10,11] = open;
        k[13,14] = open;
        k[16,17] = open;
        k[19,20] = open;
        k[22,23] = open;
        k[25,26] = open;
        k[28,29] = open;
        k[31,32] = open;
        k[34,35] = open;
        k[37,38] = open;
        k[40] = +2V5;  // here we feed the 2.5V back to the carrier.
        k[1,4,5] = open;

        // grounds
        a[1,4,5,8,9,12,13,16,17,20,21,24,25,28,29,32,33,36,37,40] = <gnd>;
        b[2,3,6,7,10,11,14,15,18,19,22,23,26,27,30,31,34,35,38,39] = <gnd>;
        c[1,4,5,8,9,12,13,16,17,20,21,24,25,28,29,32,33,36,38,40] = <gnd>;
        d[2,3,6,7,10,13,16,19,22,25,28,37,39] = <gnd>;
        e[1,4,5,8,11,14,17,20,23,26,29,32,35,38,40] = <gnd>;
        f[2,3,6,9,12,15,18,21,24,27,30,33,36,39] = <gnd>;
        g[1,4,5,8,11,14,17,20,23,26,29,32,35,38,40] = <gnd>;
        h[3,6,9,12,15,18,21,24,27,30,33,36,39] = <gnd>;
        j[1,4,5,8,11,14,17,20,23,26,29,32,35,38,40] = <gnd>;
        k[2,3,6,9,12,15,18,21,24,27,30,33,36,39] = <gnd>;
    end inst;

end design fmc_dac;
